'use strict'

// new Promise((resolve, reject) => {тело промиса})		+
//
// цепочка промисов			+ Мы используем цепочку промисов, когда хотим выполнить последовательность промисов.
//
// .then( successCallback, failureCallback ) 				+
// .catch()											+
// .finaly()										+
//
// setTimeout(() => {},1000)					+
//
// Promise.all([])	+ ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.
//
// ===================================================
// Promise.allSettled()		+ (добавлен недавно) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
// status: "fulfilled", если выполнен успешно или "rejected", если ошибка,
// value – результат, если успешно или reason – ошибка, если нет.
// ====================================================
//
// Promise.race	+ Метод очень похож на Promise.all, но ждёт только первый выполненный промис, из которого берёт результат (или ошибку).
//
// Promise.any		+ (добавлен недавно)Метод очень похож на Promise.race, но ждёт только первый успешно выполненный промис, который становится его результатом, остальные игнорируются. Если все переданные промисы отклонены, AggregateError становится ошибкой Promise.any.
//
// Promise.resolve/reject		+ (Используется крайне редко, так как есть async и await) Поэтому эти два метода по сути и ненужны
//
//
// let promise = fetch(url);	+ запрашивает по сети url и возвращает промис. Промис успешно выполняется и в свою очередь возвращает промис с объектом ответа, где находится дополнительная информация (статус ответа, заголовки) и ответ на запрос.
// Функция fetch() принимает два параметра: 1) url – адрес, по которому нужно сделать запрос;
// 2) options (необязательный) — объект конфигурации, в котором можно настроить метод запроса, тело запроса, заголовки и многое другое.

//
//response.text()	+ Чтобы прочитать полный ответ, надо вызвать метод response.text(): он тоже возвращает промис, который выполняется, когда данные полностью загружены с удалённого сервера, и возвращает эти данные.
//
//response.json() - читает данные в формате JSON.
//
// async		+
//						Пример:
// 					async function f() {
//							return 1;
//						}
//						f().then(alert); = 1
//
// Ставится перед функцией. Эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.
//
// await(можно использовать только внутри функции async)
//						Пример:
// 					работает только внутри async–функций
//						let value = await promise;
//
//Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится. Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.



